
import { DailySchedule, User, CalendarEvent } from '../types';

/**
 * Generates a direct Google Calendar template link for single events.
 */
export function generateGoogleCalendarLink(event: CalendarEvent): string {
  const formatDate = (date: Date) => date.toISOString().replace(/-|:|\.\d+/g, '');
  const baseUrl = 'https://www.google.com/calendar/render?action=TEMPLATE';
  const params = new URLSearchParams({
    text: event.title,
    dates: `${formatDate(event.start)}/${formatDate(event.end)}`,
    details: `${event.description}\n\nJustification: ${event.justification}\n\nGenerated by ChefSync Architect Engine.`,
  });
  return `${baseUrl}&${params.toString()}`;
}

/**
 * Bundles multiple events into a single ICS file.
 * Optimized for Google Calendar Import.
 */
export function downloadICS(events: CalendarEvent[]) {
  const formatDateICS = (date: Date) => date.toISOString().replace(/-|:|\.\d+/g, '').split('.')[0] + 'Z';
  
  let icsContent = [
    "BEGIN:VCALENDAR",
    "VERSION:2.0",
    "PRODID:-//ChefSync//Architect//EN",
    "CALSCALE:GREGORIAN",
    "METHOD:PUBLISH"
  ].join("\n") + "\n";

  events.forEach(event => {
    icsContent += [
      "BEGIN:VEVENT",
      `UID:${event.id}-${new Date().getTime()}@chefsync.ai`,
      `DTSTAMP:${formatDateICS(new Date())}`,
      `DTSTART:${formatDateICS(new Date(event.start))}`,
      `DTEND:${formatDateICS(new Date(event.end))}`,
      `SUMMARY:${event.title}`,
      `DESCRIPTION:${event.description.replace(/\n/g, '\\n')} - Justification: ${event.justification.replace(/\n/g, '\\n')}`,
      "END:VEVENT"
    ].join("\n") + "\n";
  });

  icsContent += "END:VCALENDAR";
  
  const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
  const url = window.URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.setAttribute('download', `ChefSync_Full_Roadmap_${new Date().toISOString().split('T')[0]}.ics`);
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  window.URL.revokeObjectURL(url);
}

export function createEventsFromSchedule(schedule: DailySchedule, user: User): CalendarEvent[] {
  const events: CalendarEvent[] = [];
  const { reminderTime, cookingSlotStart } = user.reminderPreferences;

  // 1. Logistics (Shopping) Event
  const firstDay = new Date(schedule.days[0].date);
  const shoppingDate = new Date(firstDay);
  shoppingDate.setDate(shoppingDate.getDate() - 1); 
  shoppingDate.setHours(reminderTime === 'morning' ? 10 : 17, 0, 0, 0);

  events.push({
    id: `logistics-${schedule.days[0].date}`,
    title: 'üõí ChefSync: Logistics & Stocking',
    description: 'Ensure all ingredients are verified and budget-compliant.',
    start: shoppingDate,
    end: new Date(shoppingDate.getTime() + 45 * 60 * 1000),
    type: 'shopping',
    justification: 'Early logistics prevents mid-roadmap friction.'
  });

  // 2. Daily Routine Nodes
  schedule.days.forEach(day => {
    const dayDate = new Date(day.date);
    const [startHour, startMinute] = cookingSlotStart.split(':').map(Number);
    
    // Prep Node
    const prepStart = new Date(dayDate);
    prepStart.setHours(startHour - 1, startMinute, 0, 0);
    events.push({
      id: `prep-${day.date}`,
      title: `üî™ Macro Prep: ${day.date}`,
      description: `Cross-meal preparation sequence.`,
      start: prepStart,
      end: new Date(prepStart.getTime() + 30 * 60 * 1000),
      type: 'prep',
      justification: 'Batch preparation optimizes thermal efficiency.'
    });

    // Cooking Nodes
    let currentMealTime = new Date(dayDate);
    currentMealTime.setHours(startHour, startMinute, 0, 0);

    (['breakfast', 'lunch', 'dinner'] as const).forEach((mKey) => {
      const meal = day[mKey];
      const duration = parseInt(meal.totalTime) || 30;
      events.push({
        id: `cook-${day.date}-${mKey}`,
        title: `üç≥ Execute: ${meal.recipeName}`,
        description: `Cooking window for ${mKey}.`,
        start: new Date(currentMealTime),
        end: new Date(currentMealTime.getTime() + duration * 60 * 1000),
        type: 'cooking',
        justification: `Calibrated for ${user.persona} energy cycles.`
      });
      currentMealTime = new Date(currentMealTime.getTime() + (duration + 15) * 60 * 1000);
    });
  });

  return events;
}
